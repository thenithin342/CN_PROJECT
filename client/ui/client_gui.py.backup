#!/usr/bin/env python3
"""
Client GUI - Comprehensive PyQt6 Application

This module integrates all client functionality into a single-file GUI application.
Features:
- Video grid for local and remote feeds
- Participant list with mute controls
- Presenter controls (start/stop share)
- Chat interface with file upload
- Audio/video controls
- Screen sharing viewer
"""

import sys
import asyncio
import threading
import json
import socket
import struct
import time
import os
from pathlib import Path
from typing import Dict, List, Optional, Tuple
from datetime import datetime
from collections import deque

# PyQt6 imports
from PyQt6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
    QGridLayout, QLabel, QPushButton, QTextEdit, QTextBrowser, QLineEdit, QListWidget,
    QListWidgetItem, QProgressBar, QFileDialog, QMessageBox, QInputDialog, QSizePolicy
)
from PyQt6.QtCore import Qt, QThread, pyqtSignal, QSize, QTimer, QMutex, QUrl
from PyQt6.QtCore import QMutexLocker
from PyQt6.QtGui import QImage, QPixmap, QFont, QPalette, QColor

# OpenCV for video
try:
    import cv2
    import numpy as np
    HAS_OPENCV = True
except ImportError:
    HAS_OPENCV = False
    print("[WARNING] OpenCV not available. Video features disabled.")

# Audio imports
try:
    import sounddevice as sd
    import numpy as np
    HAS_SOUNDDEVICE = True
except ImportError:
    HAS_SOUNDDEVICE = False

try:
    from opuslib import Encoder, Decoder
    HAS_OPUS = True
except (ImportError, Exception) as e:
    HAS_OPUS = False
    print(f"[WARNING] Opus library not available: {e}")
    print("Audio encoding will be disabled.")

# Screen sharing imports
try:
    import mss
    from PIL import Image as PILImage
    from io import BytesIO
    HAS_SCREEN_SHARE = True
except ImportError:
    HAS_SCREEN_SHARE = False

# Protocol imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))
from common.protocol_definitions import (
    create_login_message, create_heartbeat_message, create_logout_message
)
from common.constants import MessageTypes

# Import existing client modules
from client.audio.audio_client import AudioClient
from client.video.video_client import VideoClient
from client.files.file_client import FileClient
from client.chat.chat_client import ChatClient
from client.screen.screen_presenter import ScreenPresenter
from client.screen.screen_viewer import ScreenViewer


# ============================================================================
# VIDEO GRID WIDGET
# ============================================================================

class VideoFrame(QLabel):
    """Individual video frame widget."""
    
    def __init__(self, uid: int, username: str = None):
        super().__init__()
        self.uid = uid
        self.username = username or f"User {uid}"
        self.current_frame = None
        self.setup_ui()
    
    def setup_ui(self):
        """Setup the UI for video frame."""
        self.setMinimumSize(320, 240)
        self.setMaximumSize(640, 480)
        self.setStyleSheet("""
            QLabel {
                border: 2px solid #2C3E50;
                border-radius: 8px;
                background-color: #1A1A1A;
                color: white;
            }
        """)
        self.setText(f"{self.username}")
        self.setAlignment(Qt.AlignmentFlag.AlignCenter)
    
    def update_frame(self, frame: np.ndarray):
        """Update with new frame data."""
        try:
            self.current_frame = frame
            
            # Convert OpenCV BGR to RGB
            frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            height, width, channel = frame_rgb.shape
            bytes_per_line = 3 * width
            
            # Create QImage
            q_image = QImage(frame_rgb.data, width, height, bytes_per_line, QImage.Format.Format_RGB888)
            
            # Create QPixmap and scale
            pixmap = QPixmap.fromImage(q_image)
            scaled_pixmap = pixmap.scaled(
                self.size(),
                Qt.AspectRatioMode.KeepAspectRatio,
                Qt.TransformationMode.SmoothTransformation
            )
            
            self.setPixmap(scaled_pixmap)
            print(f"[VIDEO FRAME] Successfully updated frame for uid={self.uid}, size={width}x{height}")
            
        except Exception as e:
            print(f"[VIDEO FRAME] Error updating frame: {e}")
            import traceback
            traceback.print_exc()


class VideoGridWidget(QWidget):
    """Grid layout for video feeds."""
    
    frame_received = pyqtSignal(int, object)  # uid, frame
    
    def __init__(self):
        super().__init__()
        self.video_frames: Dict[int, VideoFrame] = {}
        self.setup_ui()
    
    def setup_ui(self):
        """Setup the video grid layout."""
        layout = QGridLayout()
        layout.setSpacing(10)
        layout.setContentsMargins(10, 10, 10, 10)
        self.setLayout(layout)
        self.setStyleSheet("""
            QWidget {
                background-color: #1A1A1A;
            }
        """)
    
    def add_video_feed(self, uid: int, username: str):
        """Add a new video feed to the grid."""
        if uid in self.video_frames:
            return
        
        frame = VideoFrame(uid, username)
        self.video_frames[uid] = frame
        self.update_grid_layout()
    
    def remove_video_feed(self, uid: int):
        """Remove a video feed from the grid."""
        if uid not in self.video_frames:
            return
        
        frame = self.video_frames[uid]
        self.layout().removeWidget(frame)
        frame.deleteLater()
        del self.video_frames[uid]
        
        self.update_grid_layout()
    
    def update_grid_layout(self):
        """Update the grid layout based on number of feeds."""
        layout = self.layout()
        
        # Clear existing layout
        for i in reversed(range(layout.count())):
            layout.itemAt(i).widget().setParent(None)
        
        # Add video frames to grid
        uids = list(self.video_frames.keys())
        num_feeds = len(uids)
        
        if num_feeds == 0:
            return
        
        # Calculate grid dimensions
        cols = 2 if num_feeds <= 4 else 3
        rows = (num_feeds + cols - 1) // cols  # Ceiling division
        
        # Add frames to grid
        for idx, uid in enumerate(uids):
            row = idx // cols
            col = idx % cols
            layout.addWidget(self.video_frames[uid], row, col)
    
    def update_frame(self, uid: int, frame: np.ndarray):
        """Update frame for a specific user."""
        if uid in self.video_frames:
            self.video_frames[uid].update_frame(frame)


# ============================================================================
# PARTICIPANT LIST WIDGET
# ============================================================================

class ParticipantItem(QWidget):
    """Widget for individual participant entry."""
    
    mute_clicked = pyqtSignal(int)  # uid
    
    def __init__(self, uid: int, username: str, is_self: bool = False):
        super().__init__()
        self.uid = uid
        self.is_self = is_self
        self._is_muted = False
        self.setup_ui(username)
    
    def setup_ui(self, username: str):
        """Setup participant item UI."""
        layout = QHBoxLayout()
        layout.setContentsMargins(5, 5, 5, 5)
        
        # Username label
        name_label = QLabel(username)
        if self.is_self:
            name_label.setText(f"{username} (You)")
            name_label.setStyleSheet("font-weight: bold; color: #3498DB;")
        else:
            name_label.setStyleSheet("color: #ECF0F1;")
        
        layout.addWidget(name_label)
        layout.addStretch()
        
        # Mute button (disabled for self)
        self.mute_btn = QPushButton("🔊" if not self.is_muted else "🔇")
        self.mute_btn.setMaximumWidth(40)
        self.mute_btn.setEnabled(not self.is_self)
        if not self.is_self:
            self.mute_btn.clicked.connect(lambda: self.mute_clicked.emit(self.uid))
        
        layout.addWidget(self.mute_btn)
        self.setLayout(layout)
    
    @property
    def is_muted(self):
        return self._is_muted
    
    def toggle_mute(self):
        """Toggle mute state and update button text."""
        self._is_muted = not self._is_muted
        self.mute_btn.setText("🔇" if self._is_muted else "🔊")


class ParticipantPanel(QWidget):
    """Panel showing participant list and controls."""
    
    def __init__(self):
        super().__init__()
        self.participants: Dict[int, ParticipantItem] = {}
        self.setup_ui()
    
    def setup_ui(self):
        """Setup participant panel UI."""
        layout = QVBoxLayout()
        layout.setSpacing(5)
        layout.setContentsMargins(10, 10, 10, 10)
        
        # Title
        title = QLabel("Participants")
        title.setFont(QFont("Arial", 12, QFont.Weight.Bold))
        title.setStyleSheet("color: #ECF0F1; padding: 5px;")
        layout.addWidget(title)
        
        # Participant list
        self.participant_list = QListWidget()
        self.participant_list.setStyleSheet("""
            QListWidget {
                background-color: #2C3E50;
                border: 1px solid #34495E;
                border-radius: 5px;
                color: #ECF0F1;
            }
            QListWidget::item {
                padding: 5px;
            }
        """)
        layout.addWidget(self.participant_list)
        
        # Controls section
        controls_title = QLabel("Controls")
        controls_title.setFont(QFont("Arial", 12, QFont.Weight.Bold))
        controls_title.setStyleSheet("color: #ECF0F1; padding: 5px; margin-top: 10px;")
        layout.addWidget(controls_title)
        
        # Store parent reference for callbacks
        self.parent_window = None
        
        # Audio button
        self.audio_btn = QPushButton("🎤 Unmute Audio")
        self.audio_btn.clicked.connect(self.toggle_audio)
        layout.addWidget(self.audio_btn)
        
        # Video button
        self.video_btn = QPushButton("📹 Start Video")
        self.video_btn.clicked.connect(self.toggle_video)
        layout.addWidget(self.video_btn)
        
        # Screen share button
        self.share_btn = QPushButton("🖥️ Start Screen Share")
        self.share_btn.clicked.connect(self.toggle_screen_share)
        layout.addWidget(self.share_btn)
        
        layout.addStretch()
        self.setLayout(layout)
        
        # Styling
        self.setStyleSheet("""
            QWidget {
                background-color: #34495E;
            }
            QPushButton {
                background-color: #3498DB;
                color: white;
                border: none;
                padding: 10px;
                border-radius: 5px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #2980B9;
            }
            QPushButton:pressed {
                background-color: #1F618D;
            }
        """)
    
    def add_participant(self, uid: int, username: str, is_self: bool = False):
        """Add a participant to the list."""
        item = ParticipantItem(uid, username, is_self)
        self.participants[uid] = item
        
        # Connect the mute_clicked signal to the parent window handler
        if self.parent_window:
            item.mute_clicked.connect(self.parent_window.on_participant_mute_clicked)
        
        list_item = QListWidgetItem()
        list_item.setSizeHint(item.sizeHint())
        self.participant_list.addItem(list_item)
        self.participant_list.setItemWidget(list_item, item)
    
    def remove_participant(self, uid: int):
        """Remove a participant from the list."""
        if uid in self.participants:
            # Find and remove the item
            for i in range(self.participant_list.count()):
                item = self.participant_list.item(i)
                if item:
                    widget = self.participant_list.itemWidget(item)
                    if widget and widget.uid == uid:
                        self.participant_list.takeItem(i)
                        break
            del self.participants[uid]
    
    def toggle_audio(self):
        """Toggle audio streaming."""
        if self.parent_window:
            self.parent_window.on_toggle_audio()
    
    def toggle_video(self):
        """Toggle video streaming."""
        if self.parent_window:
            self.parent_window.on_toggle_video()
    
    def toggle_screen_share(self):
        """Toggle screen sharing."""
        if self.parent_window:
            self.parent_window.on_toggle_screen_share()


# ============================================================================
# CHAT INTERFACE WIDGET
# ============================================================================

class ChatWidget(QWidget):
    """Chat interface with text area and input."""
    
    message_sent = pyqtSignal(str)  # message text
    file_upload = pyqtSignal(str)  # file path
    broadcast_sent = pyqtSignal(str)  # message text
    unicast_sent = pyqtSignal(int, str)  # target_uid, message text
    file_download_requested = pyqtSignal(str, str)  # fid, filename
    
    def __init__(self):
        super().__init__()
        self.setup_ui()
    
    def setup_ui(self):
        """Setup chat interface UI."""
        layout = QVBoxLayout()
        layout.setSpacing(5)
        layout.setContentsMargins(5, 5, 5, 5)
        
        # Chat text area (using QTextBrowser for link support)
        self.chat_text = QTextBrowser()
        self.chat_text.setReadOnly(True)
        self.chat_text.setOpenExternalLinks(False)  # Handle links ourselves
        self.chat_text.setStyleSheet("""
            QTextBrowser {
                background-color: #2C2C2C;
                color: #ECF0F1;
                border: 1px solid #34495E;
                border-radius: 5px;
                padding: 5px;
                font-size: 10pt;
            }
            QTextBrowser a {
                color: #3498DB;
                text-decoration: none;
            }
        """)
        # Connect anchor clicked signal to handle downloads
        self.chat_text.anchorClicked.connect(self._on_anchor_clicked)
        layout.addWidget(self.chat_text)
        
        # Input area
        input_layout = QHBoxLayout()
        
        self.input_field = QLineEdit()
        self.input_field.setPlaceholderText("Type a message...")
        self.input_field.setStyleSheet("""
            QLineEdit {
                background-color: #34495E;
                color: #ECF0F1;
                border: 1px solid #2C3E50;
                border-radius: 5px;
                padding: 5px;
            }
        """)
        self.input_field.returnPressed.connect(self.send_message)
        input_layout.addWidget(self.input_field)
        
        # Send button
        send_btn = QPushButton("Send")
        send_btn.clicked.connect(self.send_message)
        send_btn.setStyleSheet("""
            QPushButton {
                background-color: #3498DB;
                color: white;
                border: none;
                padding: 8px 15px;
                border-radius: 5px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #2980B9;
            }
        """)
        input_layout.addWidget(send_btn)
        
        # File upload button
        file_btn = QPushButton("📎")
        file_btn.setToolTip("Upload File")
        file_btn.clicked.connect(self.upload_file)
        file_btn.setMaximumWidth(50)
        file_btn.setStyleSheet("""
            QPushButton {
                background-color: #27AE60;
                color: white;
                border: none;
                padding: 8px;
                border-radius: 5px;
            }
            QPushButton:hover {
                background-color: #229954;
            }
        """)
        input_layout.addWidget(file_btn)
        
        # Broadcast button
        broadcast_btn = QPushButton("📢")
        broadcast_btn.setToolTip("Send Broadcast Message")
        broadcast_btn.clicked.connect(self.send_broadcast)
        broadcast_btn.setMaximumWidth(50)
        broadcast_btn.setStyleSheet("""
            QPushButton {
                background-color: #E74C3C;
                color: white;
                border: none;
                padding: 8px;
                border-radius: 5px;
            }
            QPushButton:hover {
                background-color: #C0392B;
            }
        """)
        input_layout.addWidget(broadcast_btn)
        
        # Private message button
        private_btn = QPushButton("🔒")
        private_btn.setToolTip("Send Private Message")
        private_btn.clicked.connect(self.send_private)
        private_btn.setMaximumWidth(50)
        private_btn.setStyleSheet("""
            QPushButton {
                background-color: #9B59B6;
                color: white;
                border: none;
                padding: 8px;
                border-radius: 5px;
            }
            QPushButton:hover {
                background-color: #8E44AD;
            }
        """)
        input_layout.addWidget(private_btn)
        
        layout.addLayout(input_layout)
        
        # Progress bar for file uploads
        self.progress_bar = QProgressBar()
        self.progress_bar.setVisible(False)
        layout.addWidget(self.progress_bar)
        
        self.setLayout(layout)
    
    def send_message(self):
        """Send chat message."""
        text = self.input_field.text().strip()
        if text:
            self.message_sent.emit(text)
            self.input_field.clear()
    
    def upload_file(self):
        """Upload file."""
        file_path, _ = QFileDialog.getOpenFileName(
            self, "Select file to upload", "", "All Files (*)"
        )
        if file_path:
            self.file_upload.emit(file_path)
    
    def send_broadcast(self):
        """Send broadcast message."""
        text = self.input_field.text().strip()
        if text:
            self.broadcast_sent.emit(text)
            self.input_field.clear()
    
    def send_private(self):
        """Send private message."""
        text = self.input_field.text().strip()
        if text:
            # Signal that will be handled by parent to select recipient
            self.unicast_sent.emit(None, text)  # None means need to select
            self.input_field.clear()
    
    def add_message(self, username: str, message: str, is_system: bool = False):
        """Add message to chat."""
        timestamp = datetime.now().strftime("%H:%M")
        if is_system:
            self.chat_text.append(f'<span style="color: #95A5A6;">[{timestamp}] {message}</span>')
        else:
            self.chat_text.append(f'<span style="color: #3498DB;">{username}:</span> {message}')
        
        # Auto scroll to bottom
        scrollbar = self.chat_text.verticalScrollBar()
        scrollbar.setValue(scrollbar.maximum())
    
    def add_file_notification(self, message: str, fid: str, filename: str, size_display: str):
        """Add file notification with download button."""
        timestamp = datetime.now().strftime("%H:%M")
        
        # Create a container widget for the file notification
        file_widget = QWidget()
        file_layout = QHBoxLayout()
        file_layout.setContentsMargins(10, 5, 10, 5)
        file_layout.setSpacing(10)
        
        # Message label with HTML formatting
        file_label = QLabel(f'<span style="color: #95A5A6;">[{timestamp}]</span> {message}')
        file_label.setStyleSheet("color: #ECF0F1; font-size: 10pt;")
        file_label.setTextFormat(Qt.TextFormat.RichText)
        file_layout.addWidget(file_label)
        
        # Download button
        download_btn = QPushButton("⬇️ Download")
        download_btn.setStyleSheet("""
            QPushButton {
                background-color: #3498DB;
                color: white;
                border: none;
                padding: 5px 15px;
                border-radius: 5px;
                font-weight: bold;
                font-size: 9pt;
            }
            QPushButton:hover {
                background-color: #2980B9;
            }
        """)
        download_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        # Store fid in the button so we can use it later
        download_btn.setProperty("fid", fid)
        download_btn.setProperty("filename", filename)
        download_btn.clicked.connect(lambda: self._on_download_clicked(download_btn))
        
        file_layout.addWidget(download_btn)
        file_layout.addStretch()
        
        file_widget.setLayout(file_layout)
        
        # Insert into chat
        scrollbar = self.chat_text.verticalScrollBar()
        at_bottom = scrollbar.value() >= scrollbar.maximum() - 10
        
        # Add as a custom HTML widget (this is a workaround since QTextEdit doesn't support widgets directly)
        # Instead, we'll add it with a clickable link style
        notification_html = f'''
        <div style="background-color: #2C3E50; padding: 8px; border-radius: 5px; margin: 5px 0;">
            <span style="color: #95A5A6;">[{timestamp}]</span> {message}
            <a href="download://{fid}" style="color: #3498DB; text-decoration: none; font-weight: bold; margin-left: 10px;">
                ⬇️ Download
            </a>
        </div>
        '''
        
        self.chat_text.append(notification_html)
        
        # Store the fid for later lookup
        if not hasattr(self, '_file_links'):
            self._file_links = {}
        self._file_links[fid] = {'filename': filename, 'size': size_display}
        
        # Auto scroll to bottom
        if at_bottom:
            scrollbar.setValue(scrollbar.maximum())
    
    def _on_download_clicked(self, button):
        """Handle download button click."""
        fid = button.property("fid")
        filename = button.property("filename")
        self.file_download_requested.emit(fid, filename)
    
    def _on_anchor_clicked(self, url):
        """Handle anchor link clicks (for download links)."""
        if url.scheme() == "download":
            fid = url.path()
            # Get filename from stored links
            if hasattr(self, '_file_links') and fid in self._file_links:
                filename = self._file_links[fid]['filename']
                self.file_download_requested.emit(fid, filename)
    
    def show_progress(self, value: int):
        """Show file upload progress."""
        self.progress_bar.setValue(value)
        self.progress_bar.setVisible(value < 100)
    
    def hide_progress(self):
        """Hide progress bar."""
        self.progress_bar.setVisible(False)
        self.progress_bar.setValue(0)


# ============================================================================
# MAIN WINDOW
# ============================================================================

class ClientMainWindow(QMainWindow):
    """Main application window."""
    
    def __init__(self, server_host: str = 'localhost', server_port: int = 9000):
        super().__init__()
        self.server_host = server_host
        self.server_port = server_port
        self.username = None
        self.uid = None
        
        # Networking components
        self.reader = None
        self.writer = None
        self.network_thread = None
        self.video_receiver_thread = None
        
        # Client modules (initialized after connection)
        self.audio_client = None
        self.video_client = None
        self.file_client = None
        self.chat_client = None
        self.screen_presenter = None
        self.screen_viewer = None
        
        # State
        self.participants: Dict[int, dict] = {}
        self.video_streams: Dict[int, np.ndarray] = {}
        self.running = False
        self.available_files = {}  # Store available files for download
        
        # Explicit state flags for media controls
        self.audio_muted = True  # Audio starts muted (user needs to unmute)
        self.video_streaming = False  # Video is off by default
        self.screen_sharing = False  # Screen sharing is off by default
        
        # Worker storage (to prevent garbage collection)
        self.upload_worker = None
        self.screen_share_start_worker = None
        self.screen_share_stop_worker = None
        
        # Setup UI
        self.setup_ui()
        self.setup_connections()
        
        # Set parent reference in participant panel
        self.participant_panel.parent_window = self
        
        # Connect video receiver
        self.setup_video_receiver()
        
        # Setup heartbeat timer to keep participants synced
        self.setup_heartbeat_timer()
    
    def setup_ui(self):
        """Setup the main window UI."""
        self.setWindowTitle("LAN Collaboration Client")
        self.setGeometry(100, 100, 1400, 900)
        
        # Central widget and main layout
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        
        # Main vertical layout for top video area and bottom chat
        main_layout = QVBoxLayout()
        main_layout.setSpacing(5)
        main_layout.setContentsMargins(10, 10, 10, 10)
        
        # Top area: Video grid and participant panel (horizontal)
        top_area = QHBoxLayout()
        
        # Video grid (left, takes most space)
        self.video_grid = VideoGridWidget()
        top_area.addWidget(self.video_grid, stretch=3)
        
        # Right panel (participants and controls)
        self.participant_panel = ParticipantPanel()
        top_area.addWidget(self.participant_panel, stretch=1)
        
        # Add top area to main layout
        main_layout.addLayout(top_area, stretch=3)
        
        # Chat widget (bottom area) - Fixed size to prevent layout issues
        self.chat_widget = ChatWidget()
        self.chat_widget.setMinimumHeight(200)
        self.chat_widget.setMaximumHeight(250)
        self.chat_widget.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)
        main_layout.addWidget(self.chat_widget, stretch=0)
        
        # Set main layout
        central_widget.setLayout(main_layout)
        
        # Set dark theme
        self.apply_dark_theme()
    
    def setup_connections(self):
        """Setup signal-slot connections."""
        self.chat_widget.message_sent.connect(self.on_send_message)
        self.chat_widget.file_upload.connect(self.on_upload_file)
        self.chat_widget.broadcast_sent.connect(self.on_send_broadcast)
        self.chat_widget.unicast_sent.connect(self.on_send_unicast)
        self.chat_widget.file_download_requested.connect(self.on_download_file)
    
    def connect_signals(self):
        """Connect signals from participant panel."""
        # Connect directly to methods (participant panel doesn't have signals)
        pass
    
    def apply_dark_theme(self):
        """Apply dark theme styling."""
        self.setStyleSheet("""
            QMainWindow {
                background-color: #1A1A1A;
            }
            QWidget {
                background-color: #1A1A1A;
                color: #ECF0F1;
            }
        """)
    
    def setup_heartbeat_timer(self):
        """Setup periodic heartbeat timer."""
        self.heartbeat_timer = QTimer()
        self.heartbeat_timer.timeout.connect(self.send_heartbeat)
        self.heartbeat_timer.setInterval(10000)  # 10 seconds
        self.heartbeat_timer.start()
    
    def send_heartbeat(self):
        """Send heartbeat message to server."""
        if self.network_thread and self.network_thread.writer:
            try:
                message = {"type": "heartbeat"}
                self.network_thread.send_message(message)
            except Exception as e:
                print(f"[GUI] Error sending heartbeat: {e}")
    
    # ========================================================================
    # CONNECTION & NETWORKING
    # ========================================================================
    
    def connect_to_server(self):
        """Connect to the server."""
        from PyQt6.QtWidgets import QInputDialog
        
        # Always show dialog to enter username
        # If username was provided via CLI, use it as default
        default_username = getattr(self, 'username', '') or ''
        text, ok = QInputDialog.getText(self, 'Login', 'Enter your username:', text=default_username)
        
        if not ok or not text:
            QMessageBox.warning(self, "Error", "Username required")
            return False
        
        self.username = text
        print(f"[GUI] Connecting as: {self.username}")
        
        # Start network thread
        self.network_thread = NetworkThread(self.server_host, self.server_port, self.username)
        self.network_thread.message_received.connect(self.handle_message)
        self.network_thread.connected.connect(self.on_connected)
        self.network_thread.disconnected.connect(self.on_disconnected)
        self.network_thread.start()
        
        return True
    
    def setup_video_receiver(self):
        """Setup video receiver for remote feeds."""
        if HAS_OPENCV:
            self.video_receiver_thread = VideoReceiverThread(self.server_host, 0)  # 0 = bind to any available port
            self.video_receiver_thread.frame_received.connect(
                lambda uid, frame: self._on_frame_received(uid, frame)
            )
            print("[GUI] Video receiver setup complete")
        else:
            print("[GUI] OpenCV not available, video receiver not started")
    
    def _on_frame_received(self, uid, frame):
        """Handle received frame."""
        print(f"[GUI] Frame received for uid={uid}, updating video grid")
        self.video_grid.update_frame(uid, frame)
    
    def start_video_receiver(self):
        """Start receiving video from remote users."""
        if self.video_receiver_thread and not self.video_receiver_thread.isRunning():
            self.video_receiver_thread.start()
    
    def stop_video_receiver(self):
        """Stop receiving video."""
        if self.video_receiver_thread and self.video_receiver_thread.isRunning():
            self.video_receiver_thread.stop()
            self.video_receiver_thread.wait()
    
    def initialize_client_modules(self):
        """Initialize client modules after successful login."""
        # Reset the counter at the start of each initialization attempt
        self._init_attempts = 0
        self._max_init_attempts = 50  # 5 seconds at 100ms intervals
        
        # Use QTimer to poll asynchronously for writer availability
        
        def check_and_init():
            if self._init_attempts >= self._max_init_attempts:
                print("[WARNING] Writer not available after max attempts, skipping module initialization")
                return
            
            self._init_attempts += 1
            
            if self.network_thread and self.network_thread.writer:
                # Writer is now available, initialize modules
                writer = self.network_thread.writer
                
                # Initialize client modules
                self.audio_client = AudioClient(server_ip=self.server_host, server_port=11000, uid=self.uid)
                self.video_client = VideoClient(server_ip=self.server_host, server_port=10000, uid=self.uid)
                self.file_client = FileClient()
                self.chat_client = ChatClient(writer)
                self.screen_presenter = ScreenPresenter(writer)
                self.screen_viewer = ScreenViewer(writer)
                
                # Set hosts and writer for modules that need it
                self.file_client.set_host(self.server_host)
                self.file_client.set_writer(writer)
                self.screen_presenter.set_host(self.server_host)
                self.screen_viewer.set_host(self.server_host)
                
                # Start video receiver
                self.start_video_receiver()
            else:
                # Schedule another check
                QTimer.singleShot(100, check_and_init)
        
        # Start the async check
        check_and_init()
            
    def on_connected(self):
        """Handle successful connection."""
        self.chat_widget.add_message("System", "Connected to server", is_system=True)
    
    def on_disconnected(self):
        """Handle disconnection."""
        self.chat_widget.add_message("System", "Disconnected from server", is_system=True)
    
    def handle_message(self, message: dict):
        """Handle incoming message from server."""
        try:
            msg_type = message.get('type', '')
            
            if msg_type == MessageTypes.LOGIN_SUCCESS:
                self.uid = message.get('uid')
                self.chat_widget.add_message("System", f"Logged in as {self.username} (uid={self.uid})", is_system=True)
                
                # Initialize client modules
                self.initialize_client_modules()
                
                # Request participant list
                self.request_participant_list()
            
            elif msg_type == MessageTypes.PARTICIPANT_LIST:
                self.update_participants(message.get('participants', []))
            
            elif msg_type == MessageTypes.USER_JOINED:
                uid = message.get('uid')
                username = message.get('username')
                self.chat_widget.add_message("System", f"{username} joined", is_system=True)
            
            elif msg_type == MessageTypes.USER_LEFT:
                uid = message.get('uid')
                username = message.get('username')
                self.chat_widget.add_message("System", f"{username} left", is_system=True)
            
            elif msg_type == MessageTypes.CHAT:
                self.handle_chat_message(message)
            
            elif msg_type == MessageTypes.BROADCAST:
                self.handle_broadcast_message(message)
            
            elif msg_type == MessageTypes.FILE_AVAILABLE:
                self.handle_file_available(message)
            
            elif msg_type == MessageTypes.FILE_UPLOAD_PORT:
                if self.file_client and self.network_thread:
                    import asyncio
                    asyncio.run_coroutine_threadsafe(
                        self.file_client.handle_message(message),
                        self.network_thread.loop
                    )
            
            elif msg_type == MessageTypes.FILE_DOWNLOAD_PORT:
                self.handle_file_download_port(message)
            
            elif msg_type == MessageTypes.UNICAST:
                self.handle_unicast_message(message)
            
            elif msg_type == MessageTypes.UNICAST_SENT:
                to_username = message.get('to_username', 'unknown')
                self.chat_widget.add_message("System", f"Private message delivered to {to_username}", is_system=True)
            
            elif msg_type == MessageTypes.ERROR:
                error_msg = message.get('message', 'Unknown error')
                self.chat_widget.add_message("System", f"Error: {error_msg}", is_system=True)
        except Exception as e:
            print(f"[GUI] Error handling message: {e}")
            import traceback
            traceback.print_exc()
    
    def request_participant_list(self):
        """Request updated participant list."""
        # Send a heartbeat to server which should trigger participant list update
        if self.network_thread:
            try:
                message = {"type": "heartbeat"}
                self.network_thread.send_message(message)
            except Exception as e:
                print(f"[GUI] Error requesting participant list: {e}")
    
    def update_participants(self, participants: List[dict]):
        """Update participant list."""
        # Clear existing
        for uid in list(self.participants.keys()):
            self.participant_panel.remove_participant(uid)
            self.video_grid.remove_video_feed(uid)
        
        # Add new participants
        for p in participants:
            uid = p.get('uid')
            username = p.get('username')
            self.participants[uid] = p
            self.participant_panel.add_participant(uid, username, uid == self.uid)
            self.video_grid.add_video_feed(uid, username)
    
    def handle_chat_message(self, message: dict):
        """Handle incoming chat message."""
        uid = message.get('uid')
        username = message.get('username')
        text = message.get('text', '')
        is_broadcast = message.get('broadcast', False)
        
        if uid != self.uid:  # Don't echo our own messages
            if is_broadcast:
                self.chat_widget.add_message(username, f"[BROADCAST] {text}")
            else:
                self.chat_widget.add_message(username, text)
    
    def handle_broadcast_message(self, message: dict):
        """Handle incoming broadcast message."""
        uid = message.get('uid')
        username = message.get('username')
        text = message.get('text', '')
        
        # Don't echo our own broadcasts
        if uid != self.uid:
            self.chat_widget.add_message(username, f"[BROADCAST] {text}")
    
    def handle_file_available(self, message: dict):
        """Handle file available notification."""
        if not self.file_client:
            return
        
        fid = message.get('fid')
        filename = message.get('filename')
        size = message.get('size')
        uploader = message.get('uploader')
        
        # Don't notify about files we uploaded ourselves
        if uploader == self.username:
            return
        
        # Format file size
        if size < 1024:
            size_str = f"{size} bytes"
        elif size < 1024 * 1024:
            size_str = f"{size / 1024:.1f} KB"
        else:
            size_str = f"{size / (1024 * 1024):.1f} MB"
        
        # Format size with proper suffix
        try:
            if size >= 1024 * 1024 * 1024:
                size_display = f"{size / (1024 * 1024 * 1024):.2f} GB"
            elif size >= 1024 * 1024:
                size_display = f"{size / (1024 * 1024):.2f} MB"
            elif size >= 1024:
                size_display = f"{size / 1024:.2f} KB"
            else:
                size_display = f"{size} bytes"
        except:
            size_display = size_str
        
        # Add notification with download button
        download_msg = f"📥 New File: <b>{filename}</b> ({size_display}) from <b>{uploader}</b>"
        
        # Store file info for potential download
        if not hasattr(self, 'available_files'):
            self.available_files = {}
        self.available_files[fid] = {
            'filename': filename,
            'size': size,
            'uploader': uploader
        }
        
        # Add message with a download action
        self.chat_widget.add_file_notification(download_msg, fid, filename, size_display)
    
    # ========================================================================
    # USER ACTIONS
    # ========================================================================
    
    def on_send_message(self, text: str):
        """Send chat message."""
        if not self.network_thread or not self.network_thread.writer:
            return
        
        message = {
            'type': MessageTypes.CHAT,
            'text': text
        }
        self.network_thread.send_message(message)
        self.chat_widget.add_message(self.username, text)
    
    def on_upload_file(self, file_path: str):
        """Handle file upload."""
        if not self.file_client:
            self.chat_widget.add_message("System", "File client not initialized", is_system=True)
            return
        
        # Check if upload is already in progress
        if self.upload_worker is not None:
            self.chat_widget.add_message("System", "File upload already in progress, please wait", is_system=True)
            return
        
        try:
            import asyncio
            self.chat_widget.add_message("System", f"Uploading file: {os.path.basename(file_path)}", is_system=True)
            # Upload file using worker thread for async operation
            worker = AsyncTaskWorker(self.file_client.upload_file, file_path)
            # Capture worker in lambda to prevent race condition
            worker.task_done.connect(lambda success, error, result, w=worker: self._on_upload_complete_with_result(success, error, result, w))
            self.upload_worker = worker
            worker.start()
            # Show progress
            self.chat_widget.show_progress(0)
            # Upload progress will be handled by the FileUploadWorker
            # The progress is updated in the worker and connected via task_done signal
        except Exception as e:
            self.chat_widget.add_message("System", f"Failed to upload file: {e}", is_system=True)
    
    def _on_upload_complete_with_result(self, success: bool, error: str, result, completing_worker=None):
        """Handle upload completion result from worker."""
        if success:
            self.chat_widget.add_message("System", "File uploaded successfully", is_system=True)
            # Use result if available
            if result is not None:
                self.chat_widget.add_message("System", f"Upload result: {result}", is_system=True)
        else:
            self.chat_widget.add_message("System", f"File upload failed: {error}", is_system=True)
        self.chat_widget.hide_progress()
        # Only clear worker reference if it's the same instance (prevents race condition)
        if completing_worker is not None and self.upload_worker is completing_worker:
            self.upload_worker = None
    
    def on_download_file(self, fid: str, filename: str):
        """Handle file download request from chat."""
        if not self.file_client:
            self.chat_widget.add_message("System", "File client not initialized", is_system=True)
            return
        
        # Check if this file is available
        if not hasattr(self, 'available_files') or fid not in self.available_files:
            self.chat_widget.add_message("System", f"File {filename} is no longer available", is_system=True)
            return
        
        # Ask user where to save the file
        from PyQt6.QtWidgets import QFileDialog
        save_path, _ = QFileDialog.getSaveFileName(
            self,
            "Save File",
            filename,
            "All Files (*)"
        )
        
        if not save_path:
            return  # User cancelled
        
        try:
            # Start download in background
            self.chat_widget.add_message("System", f"Downloading {filename}...", is_system=True)
            
            # Store the save path in pending downloads
            # The actual download will be triggered when we receive the download port
            self.file_client.pending_downloads[fid] = save_path
            
            # Send file request message to server
            message = {
                'type': 'file_request',
                'fid': fid
            }
            self.network_thread.send_message(message)
            
            self.chat_widget.add_message("System", f"Download request sent for {filename}", is_system=True)
            
        except Exception as e:
            self.chat_widget.add_message("System", f"Failed to start download: {e}", is_system=True)
            import traceback
            traceback.print_exc()
    
    def _on_download_complete(self, success: bool, error: str, result, filename: str):
        """Handle download completion."""
        if success:
            self.chat_widget.add_message("System", f"📥 Download complete: {filename}", is_system=True)
        else:
            self.chat_widget.add_message("System", f"Download failed: {error}", is_system=True)
    
    def _on_download_complete_with_cleanup(self, success: bool, error: str, result, filename: str, worker, fid: str):
        """Handle download completion and cleanup worker."""
        # Call the existing handler
        self._on_download_complete(success, error, result, filename)
        # Clean up the worker from the dictionary
        if hasattr(self, 'download_workers') and fid in self.download_workers:
            del self.download_workers[fid]
    
    def on_send_broadcast(self, text: str):
        """Send broadcast message."""
        if not self.network_thread or not self.network_thread.writer:
            self.chat_widget.add_message("System", "Not connected to server", is_system=True)
            return
        
        message = {
            'type': MessageTypes.BROADCAST,
            'text': text
        }
        self.network_thread.send_message(message)
        # Show in chat that we're broadcasting
        self.chat_widget.add_message("You", f"[BROADCAST] {text}")
    
    def on_send_unicast(self, target_uid: int, text: str):
        """Send private (unicast) message."""
        if not self.network_thread or not self.network_thread.writer:
            self.chat_widget.add_message("System", "Not connected to server", is_system=True)
            return
        
        # If no target_uid provided, show dialog to select recipient
        if target_uid is None:
            target_uid = self.select_recipient()
            if target_uid is None:
                self.chat_widget.add_message("System", "No recipient selected", is_system=True)
                return  # User cancelled
        
        message = {
            'type': MessageTypes.UNICAST,
            'target_uid': target_uid,
            'text': text
        }
        self.network_thread.send_message(message)
        
        # Show in chat that we're sending a private message
        target_username = self.get_username_by_uid(target_uid)
        self.chat_widget.add_message("You", f"(→ {target_username}) {text}")
    
    def select_recipient(self) -> Optional[int]:
        """Show dialog to select message recipient."""
        # Build list of recipients (exclude self)
        recipients = []
        for uid, participant in self.participants.items():
            if uid != self.uid:
                username = participant.get('username', f'User {uid}')
                recipients.append(f"{uid} - {username}")
        
        if not recipients:
            QMessageBox.warning(self, "No Recipients", "No other participants available")
            return None
        
        item, ok = QInputDialog.getItem(
            self, 
            "Select Recipient", 
            "Choose who to send a private message to:",
            recipients,
            0, 
            False
        )
        
        if ok and item:
            # Extract UID from selection
            uid_str = item.split(' - ')[0]
            return int(uid_str)
        
        return None
    
    def get_username_by_uid(self, uid: int) -> str:
        """Get username by UID."""
        participant = self.participants.get(uid, {})
        return participant.get('username', f'User {uid}')
    
    def handle_file_download_port(self, message: dict):
        """Handle file download port message from server."""
        fid = message.get('fid')
        filename = message.get('filename')
        size = message.get('size')
        port = message.get('port')
        
        # Get the save path from pending downloads
        save_path = self.file_client.pending_downloads.get(fid) if self.file_client else None
        
        if not save_path:
            self.chat_widget.add_message("System", f"No save path found for {filename}", is_system=True)
            return
        
        # Remove from pending
        if fid in self.file_client.pending_downloads:
            del self.file_client.pending_downloads[fid]
        
        # Start download in background using worker
        try:
            # Create download worker
            worker = AsyncTaskWorker(
                self.file_client.do_file_download,
                fid,
                filename,
                size,
                port,
                save_path
            )
            # Store worker in dictionary to track downloads
            if not hasattr(self, 'download_workers'):
                self.download_workers = {}
            self.download_workers[fid] = {'worker': worker, 'fid': fid, 'filename': filename}
            
            worker.task_done.connect(
                lambda success, error, result, worker_ref=worker, file_id=fid, fname=filename: 
                self._on_download_complete_with_cleanup(success, error, result, fname, worker_ref, file_id)
            )
            worker.start()
        except Exception as e:
            self.chat_widget.add_message("System", f"Failed to start download: {e}", is_system=True)
            import traceback
            traceback.print_exc()
    
    def handle_unicast_message(self, message: dict):
        """Handle incoming unicast (private) message."""
        from_uid = message.get('from_uid')
        from_username = message.get('from_username', 'unknown')
        text = message.get('text', '')
        
        # Display as private message
        self.chat_widget.add_message(
            f"[PRIVATE] {from_username}", 
            text
        )
    
    def on_participant_mute_clicked(self, uid: int):
        """Handle participant mute button click."""
        # Toggle the mute state in the UI
        participant_item = self.participant_panel.participants.get(uid)
        if participant_item:
            participant_item.toggle_mute()
            
            # Perform actual mute logic with audio client
            if self.audio_client:
                if participant_item.is_muted:
                    self.audio_client.mute_participant(uid)
                    self.chat_widget.add_message("System", f"Muted user {uid}", is_system=True)
                else:
                    self.audio_client.unmute_participant(uid)
                    self.chat_widget.add_message("System", f"Unmuted user {uid}", is_system=True)
            else:
                if participant_item.is_muted:
                    self.chat_widget.add_message("System", f"Muted user {uid} (audio client not available)", is_system=True)
                else:
                    self.chat_widget.add_message("System", f"Unmuted user {uid} (audio client not available)", is_system=True)
    
    def on_toggle_audio(self):
        """Toggle audio streaming."""
        if not self.audio_client:
            self.chat_widget.add_message("System", "Audio client not initialized", is_system=True)
            return
        
        if self.audio_muted:
            # Unmute (start) audio
            try:
                self.audio_client.start_recording()
                self.audio_muted = False
                self.participant_panel.audio_btn.setText("🎤 Mute Audio")
                self.chat_widget.add_message("System", "Audio unmuted", is_system=True)
            except Exception as e:
                self.chat_widget.add_message("System", f"Failed to start audio: {e}", is_system=True)
        else:
            # Mute (stop) audio
            try:
                self.audio_client.stop_recording()
                self.audio_muted = True
                self.participant_panel.audio_btn.setText("🎤 Unmute Audio")
                self.chat_widget.add_message("System", "Audio muted", is_system=True)
            except Exception as e:
                self.chat_widget.add_message("System", f"Failed to stop audio: {e}", is_system=True)
    
    def on_toggle_video(self):
        """Toggle video streaming."""
        if not self.video_client:
            self.chat_widget.add_message("System", "Video client not initialized", is_system=True)
            return
        
        if self.video_streaming:
            # Stop video
            try:
                self.video_client.stop_streaming()
                self.video_streaming = False
                self.participant_panel.video_btn.setText("📹 Start Video")
                self.chat_widget.add_message("System", "Video stopped", is_system=True)
            except Exception as e:
                self.chat_widget.add_message("System", f"Failed to stop video: {e}", is_system=True)
        else:
            # Start video
            try:
                self.video_client.start_streaming()
                self.video_streaming = True
                self.participant_panel.video_btn.setText("📹 Stop Video")
                self.chat_widget.add_message("System", "Video started", is_system=True)
            except Exception as e:
                self.chat_widget.add_message("System", f"Failed to start video: {e}", is_system=True)
    
    def on_toggle_screen_share(self):
        """Toggle screen sharing."""
        if not self.screen_presenter:
            self.chat_widget.add_message("System", "Screen presenter not initialized", is_system=True)
            return
        
        if self.screen_sharing:
            # Stop screen share
            # Check if stop worker is already running
            if self.screen_share_stop_worker is not None:
                self.chat_widget.add_message("System", "Screen share stop already in progress", is_system=True)
                return
            
            try:
                worker = AsyncTaskWorker(self.screen_presenter.stop_presentation)
                # Capture worker in lambda to prevent race condition
                worker.task_done.connect(lambda success, error, result, w=worker: self._on_screen_share_stopped_with_result(success, error, result, w))
                self.screen_share_stop_worker = worker
                worker.start()
            except Exception as e:
                self.chat_widget.add_message("System", f"Failed to stop screen share: {e}", is_system=True)
                self.screen_share_stop_worker = None
        else:
            # Start screen share
            # Check if start worker is already running
            if self.screen_share_start_worker is not None:
                self.chat_widget.add_message("System", "Screen share start already in progress", is_system=True)
                return
            
            try:
                worker = AsyncTaskWorker(self.screen_presenter.start_presentation)
                # Capture worker in lambda to prevent race condition
                worker.task_done.connect(lambda success, error, result, w=worker: self._on_screen_share_started_with_result(success, error, result, w))
                self.screen_share_start_worker = worker
                worker.start()
            except Exception as e:
                self.chat_widget.add_message("System", f"Failed to start screen share: {e}", is_system=True)
                self.screen_share_start_worker = None
    
    def _on_screen_share_started_with_result(self, success: bool, error: str, result, completing_worker=None):
        """Handle screen share started result from worker."""
        self._on_screen_share_started(error if not success else None)
        # Only clear worker reference if it's the same instance (prevents race condition)
        if completing_worker is not None and self.screen_share_start_worker is completing_worker:
            self.screen_share_start_worker = None
    
    def _on_screen_share_stopped_with_result(self, success: bool, error: str, result, completing_worker=None):
        """Handle screen share stopped result from worker."""
        self._on_screen_share_stopped(error if not success else None)
        # Only clear worker reference if it's the same instance (prevents race condition)
        if completing_worker is not None and self.screen_share_stop_worker is completing_worker:
            self.screen_share_stop_worker = None
    
    def _on_screen_share_started(self, error: str = None):
        """Handle screen share started."""
        if error:
            self.chat_widget.add_message("System", f"Failed to start screen share: {error}", is_system=True)
        else:
            self.screen_sharing = True
            self.participant_panel.share_btn.setText("🖥️ Stop Screen Share")
            self.chat_widget.add_message("System", "Screen share started", is_system=True)
    
    def _on_screen_share_stopped(self, error: str = None):
        """Handle screen share stopped."""
        if error:
            self.chat_widget.add_message("System", f"Failed to stop screen share: {error}", is_system=True)
        else:
            self.screen_sharing = False
            self.participant_panel.share_btn.setText("🖥️ Start Screen Share")
            self.chat_widget.add_message("System", "Screen share stopped", is_system=True)
    
    # ========================================================================
    # CLEANUP
    # ========================================================================
    
    def closeEvent(self, event):
        """Handle window close event."""
        # Stop heartbeat timer
        if hasattr(self, 'heartbeat_timer'):
            self.heartbeat_timer.stop()
        
        # Stop video receiver
        self.stop_video_receiver()
        
        # Clean up audio/video clients
        if self.audio_client:
            self.audio_client.cleanup()
        if self.video_client:
            self.video_client.cleanup()
        
        # Stop network thread
        if self.network_thread:
            self.network_thread.stop()
            self.network_thread.wait()
        
        event.accept()


# ============================================================================
# VIDEO RECEIVER THREAD (for remote feeds via UDP)
# ============================================================================

class VideoReceiverThread(QThread):
    """Thread for receiving video frames via UDP and displaying them."""
    
    frame_received = pyqtSignal(int, object)  # uid, frame
    
    def __init__(self, server_ip: str, server_port: int = 0):
        super().__init__()
        self.server_ip = server_ip
        self.server_port = server_port  # 0 = bind to any available port
        self.socket = None
        self._running = False
        self._running_mutex = QMutex()
    
    def _is_running(self) -> bool:
        """Thread-safe read of running flag."""
        with QMutexLocker(self._running_mutex):
            return self._running
    
    def _set_running(self, value: bool):
        """Thread-safe write to running flag."""
        with QMutexLocker(self._running_mutex):
            self._running = value
    
    def run(self):
        """Run the video receiver loop."""
        if not HAS_OPENCV:
            print("[VIDEO RECEIVER] OpenCV not available")
            return
        
        try:
            self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            self.socket.bind(('', self.server_port))  # Bind to available port
            # Get the actual port assigned
            actual_port = self.socket.getsockname()[1]
            self.socket.settimeout(1.0)
            self._set_running(True)
            
            print(f"[VIDEO RECEIVER] Listening on port {actual_port}")
            
            while self._is_running():
                try:
                    data, addr = self.socket.recvfrom(65536)
                    self._process_frame(data, addr)
                except socket.timeout:
                    continue
                except Exception as e:
                    if self._is_running():
                        print(f"[VIDEO RECEIVER] Error: {e}")
        finally:
            self.cleanup()
    
    def _process_frame(self, frame_data: bytes, addr: Tuple[str, int]):
        """Process received frame data."""
        try:
            # Parse broadcast header if present: uid (4 bytes) + timestamp (8 bytes) = 12 bytes
            if len(frame_data) < 12:
                # No header, treat entire data as frame
                uid = hash(addr) % 0xFFFFFFFF
                frame_only = frame_data
            else:
                # Extract uid from first 4 bytes (big-endian)
                uid = struct.unpack('>I', frame_data[:4])[0]
                # Skip 12-byte broadcast header (uid + timestamp)
                frame_only = frame_data[12:]
            
            # Decode JPEG frame
            nparr = np.frombuffer(frame_only, np.uint8)
            frame = cv2.imdecode(nparr, cv2.IMREAD_COLOR)
            
            if frame is not None:
                self.frame_received.emit(uid, frame)
                print(f"[VIDEO RECEIVER] Successfully decoded and displaying frame from uid={uid}")
        
        except Exception as e:
            print(f"[VIDEO RECEIVER] Frame processing error: {e}")
            import traceback
            traceback.print_exc()
    
    def stop(self):
        """Stop the receiver."""
        self._set_running(False)
    
    def cleanup(self):
        """Clean up resources."""
        if self.socket:
            self.socket.close()
            self.socket = None


# ============================================================================
# ASYNC TASK WORKER
# ============================================================================

class AsyncTaskWorker(QThread):
    """Worker thread for running async tasks."""
    
    task_done = pyqtSignal(bool, str, object)  # success, error, result
    
    def __init__(self, async_func, *args, **kwargs):
        super().__init__()
        self.async_func = async_func
        self.args = args
        self.kwargs = kwargs
    
    def run(self):
        """Run the async task in this thread's event loop."""
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        
        try:
            result = loop.run_until_complete(self.async_func(*self.args, **self.kwargs))
            self.task_done.emit(True, None, result)
        except Exception as e:
            self.task_done.emit(False, str(e), None)
        finally:
            loop.close()


# ============================================================================
# NETWORK THREAD
# ============================================================================

class NetworkThread(QThread):
    """Thread for handling network communication."""
    
    message_received = pyqtSignal(dict)
    connected = pyqtSignal()
    disconnected = pyqtSignal()
    
    def __init__(self, host: str, port: int, username: str):
        super().__init__()
        self.host = host
        self.port = port
        self.username = username
        self.writer = None
        self.reader = None
        self.running = False
        self.loop = None
        self.loop_ready = threading.Event()
    
    def run(self):
        """Run network loop."""
        self.loop = asyncio.new_event_loop()
        asyncio.set_event_loop(self.loop)
        self.loop_ready.set()
        self.loop.run_until_complete(self._connect_and_listen())
    
    async def _connect_and_listen(self):
        """Connect to server and listen for messages."""
        try:
            self.reader, self.writer = await asyncio.open_connection(self.host, self.port)
            self.connected.emit()
            self.running = True
            
            # Send login
            login_msg = create_login_message(self.username)
            await self.send_message_async(login_msg)
            
            # Listen for messages
            while self.running:
                data = await self.reader.readline()
                if not data:
                    break
                
                try:
                    message = json.loads(data.decode('utf-8').strip())
                    self.message_received.emit(message)
                except json.JSONDecodeError:
                    pass
        
        except Exception as e:
            print(f"[NETWORK] Error: {e}")
        finally:
            self.disconnected.emit()
            if self.writer:
                self.writer.close()
                await self.writer.wait_closed()
    
    async def send_message_async(self, message: dict):
        """Send message asynchronously."""
        if not self.writer:
            return
        
        try:
            msg_data = json.dumps(message).encode('utf-8') + b'\n'
            self.writer.write(msg_data)
            await self.writer.drain()
        except Exception as e:
            print(f"[NETWORK] Send error: {e}")
    
    def send_message(self, message: dict):
        """Send message from main thread."""
        # Wait for event loop to be ready before sending
        if not self.loop_ready.wait(timeout=5.0):
            print("[NETWORK] Warning: Event loop not ready, message may not be sent")
            return
        
        if self.loop:
            asyncio.run_coroutine_threadsafe(self.send_message_async(message), self.loop)
    
    def stop(self):
        """Stop network thread and close network resources."""
        try:
            self.running = False
            
            # If loop exists and is running, schedule cleanup and stop
            if self.loop and not self.loop.is_closed():
                # Close writer and stop loop
                if self.writer:
                    try:
                        # Schedule writer close on the event loop and wait for completion
                        future = asyncio.run_coroutine_threadsafe(
                            self._close_writer(), 
                            self.loop
                        )
                        # Block on the future result with timeout to ensure cleanup completes
                        try:
                            future.result(timeout=5.0)
                        except asyncio.TimeoutError:
                            print("[NETWORK] Warning: Writer close timed out after 5 seconds")
                        except Exception as e:
                            print(f"[NETWORK] Error waiting for writer close: {e}")
                    except Exception as e:
                        print(f"[NETWORK] Error scheduling writer close: {e}")
                
                # Stop the event loop
                try:
                    self.loop.call_soon_threadsafe(self.loop.stop)
                except Exception as e:
                    print(f"[NETWORK] Error stopping event loop: {e}")
        except Exception as e:
            print(f"[NETWORK] Error in stop(): {e}")
    
    async def _close_writer(self):
        """Close writer gracefully."""
        try:
            if self.writer:
                self.writer.close()
                # Use timeout to prevent indefinite hanging
                try:
                    await asyncio.wait_for(self.writer.wait_closed(), timeout=5.0)
                except asyncio.TimeoutError:
                    print("[NETWORK] Warning: Writer wait_closed() timed out after 5 seconds")
        except Exception as e:
            print(f"[NETWORK] Error closing writer: {e}")


# ============================================================================
# MAIN ENTRY POINT
# ============================================================================

def main():
    """Main entry point."""
    app = QApplication(sys.argv)
    
    # Get server IP from environment or use default
    server_host = os.environ.get('SERVER_IP', 'localhost')
    server_port = int(os.environ.get('SERVER_PORT', '9000'))
    
    # Create and show window
    window = ClientMainWindow(server_host, server_port)
    window.show()
    
    # Connect to server
    if not window.connect_to_server():
        sys.exit(1)
    
    # Run application
    sys.exit(app.exec())


if __name__ == "__main__":
    main()
